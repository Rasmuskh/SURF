static const char *RcsId = "$Id: DevServ.cpp 13293 2009-04-07 10:53:56Z pascal_verdier $";
//+=============================================================================
//
// file :         CornerStone130.cpp
//
// description :  C++ source for the CornerStone130 and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                CornerStone130 are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: pascal_verdier $
//
// $Revision: 13293 $
//
// $Revision: 13293 $
// $Date: 2009-04-07 12:53:56 +0200 (Tue, 07 Apr 2009) $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source$
// $Log$
// Revision 3.5  2007/10/24 12:07:35  pascal_verdier
// Another spelling mistake correction
//
// Revision 3.4  2007/10/23 14:04:30  pascal_verdier
// Spelling mistakes correction
//
// Revision 3.3  2005/03/02 14:06:15  pascal_verdier
// namespace is different than class name.
//
// Revision 3.2  2004/11/08 11:33:16  pascal_verdier
// if device property not found in database, it takes class property value if exists.
//
// Revision 3.1  2004/09/06 09:27:05  pascal_verdier
// Modified for Tango 5 compatibility.
//
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//  Abort   |  abort()
//
//===================================================================


#include <tango.h>
#include <CornerStone130.h>
#include <CornerStone130Class.h>
#include <yat4tango/InnerAppender.h>
#include <yat/utils/StringTokenizer.h>
#include <yat/utils/XString.h>

namespace CornerStone130_ns
{

//=============================================================================
//- Check CHECK_HW_INTERFACE
//=============================================================================
#define CHECK_HW_INTERFACE() \
if (!m_hwInterface) \
{ \
	THROW_DEVFAILED( \
      _CPTC("DEVICE_ERROR"), \
			_CPTC("Request aborted - the hardware interface isn't accessible"), \
			_CPTC("CornerStone130::check_hw_interface")); \
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::CornerStone130(string &s)
// 
// description : 	constructor for simulated CornerStone130
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
CornerStone130::CornerStone130(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

CornerStone130::CornerStone130(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

CornerStone130::CornerStone130(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void CornerStone130::delete_device()
{
	//	Delete device allocated objects
	if (m_hwInterface)
  {
		delete m_hwInterface;
	  m_hwInterface = NULL;
  }
	
  m_filters.clear();
  m_gratings.clear();

	//-Release LogAdapter
	yat4tango::InnerAppender::release(this);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void CornerStone130::init_device()
{
	//- initialization
	m_init_device_done = false;
	m_hwInterface = NULL;
	
	m_curr_status = "Init in progress ...";
	m_curr_state = Tango::INIT;
	
	//- Initialize InnerAppender
	//--------------------------------
	try
	{
		yat4tango::InnerAppender::initialize(this, 1024);
	}
	catch (Tango::DevFailed& df)
	{
		m_curr_state = Tango::FAULT;
		m_curr_status = "Initialization failed - could not instanciate the InnerAppender\n";
		return;
	}	
	
	INFO_STREAM << "CornerStone130::CornerStone130() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	try
	{
		get_device_property();	
	}
	catch (Tango::DevFailed& Err)
	{
		ERROR_STREAM << Err << std::endl;
		m_curr_status = Err.errors[0].desc;
		m_curr_state = Tango::FAULT;
		return;
	}
	catch (...)
	{
		ERROR_STREAM << "CornerStone130::init_device - get_device_property()" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to read device properties, caught[...]!";
		return;	
	}	
	
	try
	{
		//- parse the properties
		parse_gratings_prop();
		parse_filters_prop();
	}
	catch(Tango::DevFailed& Err)
	{
		ERROR_STREAM << Err << std::endl;
		m_curr_status = string(Err.errors[0].desc);
		m_curr_state = Tango::FAULT;
		return;
	}
	catch(...)
	{
		ERROR_STREAM << "CornerStone130::init_device - failed to parse properties()" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to parse properties, caught[...]!";
		return;	
	}
	
  DEBUG_STREAM << "CornerStone130::init_device - create hardware interface..." << std::endl;
  //- Instanciate the hardware interface
  m_hwInterface = new HardwareInterface(this, gpibDeviceUrl, pollingPeriod, 
    readDelay, gratingWriteDelay, filterWriteDelay, waveLengthWriteDelay);

	if (!m_hwInterface)
	{
		ERROR_STREAM << "CornerStone130::init_device - failed to create HW interface" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to create HW interface, caught[...]!";
		return;		
  }
	
  DEBUG_STREAM << "CornerStone130::init_device - open communication with hardware..." << std::endl;	
  // open communication
  try
  {
    m_hwInterface->open_com();
	}	
	catch(Tango::DevFailed& Err)
	{
	  ERROR_STREAM << Err << std::endl;
	  m_curr_status = string(Err.errors[0].desc);
    m_curr_state = Tango::FAULT;
    return;
  }
	catch(...)
	{
	  ERROR_STREAM << "CornerStone130::init_device - failed to open communication!" << std::endl;
	  m_curr_state = Tango::FAULT;
	  m_curr_status = "Failed to open communication, caught[...]!";
    return;
	}
	
  // set grating labels
  DEBUG_STREAM << "CornerStone130::init_device - set grating labels and ranges defined in property..." << std::endl;
  try
  {
    for (Gratings_it_t it = m_gratings.begin(); it != m_gratings.end(); ++it)
    {
      m_hwInterface->set_grating_label(it->first, (it->second).label);
    }
  }
	catch(Tango::DevFailed& Err)
	{
		ERROR_STREAM << Err << std::endl;
		m_curr_status = string(Err.errors[0].desc);
    m_curr_state = Tango::FAULT;
    return;
  }
	catch(...)
	{
		ERROR_STREAM << "CornerStone130::init_device - failed to set grating labels!" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to set grating labels, caught[...]!";
    return;
	}

  // set filter labels
  DEBUG_STREAM << "CornerStone130::init_device - set filter labels defined in property..." << std::endl;
  try
  {
    for (Filters_it_t it = m_filters.begin(); it != m_filters.end(); ++it)
    {
      m_hwInterface->set_filter_label(it->first, it->second);
    }
  }
	catch(Tango::DevFailed& Err)
	{
		ERROR_STREAM << Err << std::endl;
		m_curr_status = string(Err.errors[0].desc);
    m_curr_state = Tango::FAULT;
    return;
  }
	catch(...)
	{
		ERROR_STREAM << "CornerStone130::init_device - failed to set filter labels!" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to set filter labels, caught[...]!";
    return;
	}

  // set user unit
  try
  {
    m_hwInterface->set_unit(operationalUnit);
  }
	catch(Tango::DevFailed& Err)
	{
		ERROR_STREAM << Err << std::endl;
		m_curr_status = string(Err.errors[0].desc);
    m_curr_state = Tango::FAULT;
    return;
  }
	catch(...)
	{
		ERROR_STREAM << "CornerStone130::init_device - failed to set operational unit!" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to set operational unit, caught[...]!";
    return;
	}

  // start device task
  try
  {
    DEBUG_STREAM << "CornerStone130::init_device - starting task..." << std::endl;
    this->m_hwInterface->go();
  }
  catch (Tango::DevFailed & Err)
  {
		ERROR_STREAM << Err << std::endl;
		m_curr_status = string(Err.errors[0].desc);
    m_curr_state = Tango::FAULT;
    return;
  }
  catch (...)
  {
		ERROR_STREAM << "CornerStone130::init_device - failed to start task!" << std::endl;
		m_curr_state = Tango::FAULT;
		m_curr_status = "Failed to start task, caught[...]!";
    return;
  }

	//- initialization ok
	//------------------------
	m_init_device_done = true;
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void CornerStone130::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Gratings"));
	dev_prop.push_back(Tango::DbDatum("Filters"));
	dev_prop.push_back(Tango::DbDatum("OperationalUnit"));
	dev_prop.push_back(Tango::DbDatum("GpibDeviceUrl"));
	dev_prop.push_back(Tango::DbDatum("PollingPeriod"));
	dev_prop.push_back(Tango::DbDatum("ReadDelay"));
	dev_prop.push_back(Tango::DbDatum("FilterWriteDelay"));
	dev_prop.push_back(Tango::DbDatum("GratingWriteDelay"));
	dev_prop.push_back(Tango::DbDatum("WaveLengthWriteDelay"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	CornerStone130Class	*ds_class =
		(static_cast<CornerStone130Class *>(get_device_class()));
	int	i = -1;

	//	Try to initialize Gratings from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  gratings;
	else {
		//	Try to initialize Gratings from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  gratings;
	}
	//	And try to extract Gratings value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gratings;

	//	Try to initialize Filters from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  filters;
	else {
		//	Try to initialize Filters from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  filters;
	}
	//	And try to extract Filters value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filters;

	//	Try to initialize OperationalUnit from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  operationalUnit;
	else {
		//	Try to initialize OperationalUnit from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  operationalUnit;
	}
	//	And try to extract OperationalUnit value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  operationalUnit;

	//	Try to initialize GpibDeviceUrl from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  gpibDeviceUrl;
	else {
		//	Try to initialize GpibDeviceUrl from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  gpibDeviceUrl;
	}
	//	And try to extract GpibDeviceUrl value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gpibDeviceUrl;

	//	Try to initialize PollingPeriod from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pollingPeriod;
	else {
		//	Try to initialize PollingPeriod from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pollingPeriod;
	}
	//	And try to extract PollingPeriod value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pollingPeriod;

	//	Try to initialize ReadDelay from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  readDelay;
	else {
		//	Try to initialize ReadDelay from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  readDelay;
	}
	//	And try to extract ReadDelay value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  readDelay;

	//	Try to initialize FilterWriteDelay from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  filterWriteDelay;
	else {
		//	Try to initialize FilterWriteDelay from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  filterWriteDelay;
	}
	//	And try to extract FilterWriteDelay value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filterWriteDelay;

	//	Try to initialize GratingWriteDelay from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  gratingWriteDelay;
	else {
		//	Try to initialize GratingWriteDelay from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  gratingWriteDelay;
	}
	//	And try to extract GratingWriteDelay value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  gratingWriteDelay;

	//	Try to initialize WaveLengthWriteDelay from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  waveLengthWriteDelay;
	else {
		//	Try to initialize WaveLengthWriteDelay from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  waveLengthWriteDelay;
	}
	//	And try to extract WaveLengthWriteDelay value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  waveLengthWriteDelay;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	//- Create properties
	//----------------------------
	Tango::DbData data_put;
	
	// Gratings
	//-------------------------------
	if (dev_prop[0].is_empty())
	{
		Tango::DbDatum	prop("Gratings");
		prop << "<must be defined>";
		data_put.push_back(prop);
    INFO_STREAM<<"Undefined critical property <Gratings> [check property and restart device]";
	}
	
	//- Filters
	//-------------------------------
	if (dev_prop[1].is_empty())
	{
		Tango::DbDatum	prop("Filters");
		prop <<	"<must be defined>";
		data_put.push_back(prop);
		INFO_STREAM << "Undefined critical property <Filters> [check property and restart device]" <<std::endl;
	}
	
	//- OperationalUnit
	//-------------------------------
	if (dev_prop[2].is_empty())
	{
		Tango::DbDatum  prop("OperationalUnit");
		prop << operationalUnit;
		data_put.push_back(prop);
    INFO_STREAM << "Undefined <OperationalUnit> property - using default value: nm" <<std::endl;
	}
	
	//- GpibDeviceUrl
	//-------------------------------
	if (dev_prop[3].is_empty())
	{
		Tango::DbDatum  prop("GpibDeviceUrl");
		prop << "<must be defined>";
		data_put.push_back(prop);
		INFO_STREAM << "Undefined critical property <GpibDeviceUrl> [check property and restart device]" <<std::endl;
	}
	
	
	//- write default property if created
	//-------------------------------------
	if (!data_put.empty())
		get_db_device()->put_property(data_put);

	//- Check Gratings
	//----------------------
	if ((gratings.size() == 0) || (gratings[0].find("must be defined") != std::string::npos))
	{
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
			_CPTC("Undefined critical property <Gratings> [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
	}
	
	//- Check Filters
	//----------------------
	if ((filters.size() == 0) || (filters[0].find("must be defined") != std::string::npos))
	{
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
			_CPTC("Undefined critical property <Filters> [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property"));
	}
	
	//- Check GpibDeviceUrl
	//------------------------------
	if (gpibDeviceUrl.empty() || (gpibDeviceUrl.find("must be filled") != std::string::npos))
	{
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
			_CPTC("Undefined critical property <GpibDeviceUrl> [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
	}	

  //- Check user unit
  //------------------
  if ((operationalUnit.find("nm") == std::string::npos) &&
      (operationalUnit.find("um") == std::string::npos) &&
      (operationalUnit.find("wm") == std::string::npos))
  {
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
      _CPTC("Bad definition for property <OperationalUnit>: available values are: nm, um, wm. [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
  }

  // check delays
  if (readDelay <= 0)
  {
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
      _CPTC("Bad definition for property <ReadDelay>: should be strictly positive [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
  }

  if (filterWriteDelay <= 0)
  {
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
      _CPTC("Bad definition for property <FilterWriteDelay>: should be strictly positive [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
  }

  if (waveLengthWriteDelay <= 0)
  {
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
      _CPTC("Bad definition for property <WaveLengthWriteDelay>: should be strictly positive [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
  }

  if (gratingWriteDelay <= 0)
  {
		THROW_DEVFAILED(
      _CPTC("CONFIGURATION_ERROR"),
      _CPTC("Bad definition for property <GratingWriteDelay>: should be strictly positive [check property and restart device]"),
			_CPTC("CornerStone130::get_device_property "));
  }
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void CornerStone130::always_executed_hook()
{
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_attr_hardware(vector<long> &attr_list)
{
	// DEBUG_STREAM << "CornerStone130::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_gratingMinWL
// 
// description : 	Extract real attribute values for gratingMinWL acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_gratingMinWL(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "CornerStone130::read_gratingMinWL(Tango::Attribute &attr) entering... "<< endl;
  
  static Tango::DevDouble __grating_min_wl__ = yat::IEEE_NAN;

  CHECK_HW_INTERFACE();

  // get current grating number
  yat::uint16 nb = m_hwInterface->get_grating_nb();

  // get associated max wavelength value
  __grating_min_wl__ = m_gratings[nb].minWaveLength;

	attr.set_value(&__grating_min_wl__);

}


//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::write_shutterClosed
// 
// description : 	Write shutterClosed attribute values to hardware.
//
//-----------------------------------------------------------------------------
void CornerStone130::write_shutterClosed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "CornerStone130::write_shutterClosed(Tango::WAttribute &attr) entering... "<< endl;
	
	//- Check device state
	if (this->dev_state() != Tango::STANDBY)
	{
		THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
			_CPTC("Failed to change shutter state - Device state must be STANDBY"),
			_CPTC("CornerStone130::write_shutterClosed"));
  }

  CHECK_HW_INTERFACE();

	//- get the shutter command
	E_shutter_state_t l_cmd = E_NONE;
	bool b_val = false;
	attr.get_write_value(b_val);
			
	if (b_val)
		l_cmd = E_CLOSED;	
	else
		l_cmd = E_OPENED;
			
  // send command
	m_hwInterface->set_shutter_state(l_cmd);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_gratingLabel
// 
// description : 	Extract real attribute values for gratingLabel acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_gratingLabel(Tango::Attribute &attr)
{
	// DEBUG_STREAM << "CornerStone130::read_gratingLabel entering... "<< endl;
	
	static char * __grating_label_addr__;
	static std::string __grating_label__;

  CHECK_HW_INTERFACE();

  // get current grating label
  __grating_label__ = m_hwInterface->get_grating_label();
  __grating_label_addr__ = const_cast<char*>(__grating_label__.c_str());      

  attr.set_value(&__grating_label_addr__);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_gratingMaxWL
// 
// description : 	Extract real attribute values for gratingMaxWL acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_gratingMaxWL(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "CornerStone130::read_gratingMaxWL entering... "<< endl;

  static Tango::DevDouble __grating_max_wl__ = yat::IEEE_NAN;

  CHECK_HW_INTERFACE();

  // get current grating number
  yat::uint16 nb = m_hwInterface->get_grating_nb();

  // get associated max wavelength value
  __grating_max_wl__ = m_gratings[nb].maxWaveLength;

	attr.set_value(&__grating_max_wl__);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_filterNumber
// 
// description : 	Extract real attribute values for filterNumber acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_filterNumber(Tango::Attribute &attr)
{
	// DEBUG_STREAM << "CornerStone130::read_filterNumber entering... "<< endl;

  static Tango::DevUShort __filter_nb__ = 0;

	CHECK_HW_INTERFACE();

  // get current filter number
	__filter_nb__ = m_hwInterface->get_filter_nb();
	attr.set_value(&__filter_nb__);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::write_filterNumber
// 
// description : 	Write filterNumber attribute values to hardware.
//
//-----------------------------------------------------------------------------
void CornerStone130::write_filterNumber(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "CornerStone130::write_filterNumber(Tango::WAttribute &attr) entering... "<< endl;

	//- Check device state
	if (this->dev_state() != Tango::STANDBY)
	{
		THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
			_CPTC("Failed to change filter number - Device state must be STANDBY"),
			_CPTC("CornerStone130::write_filterNumber"));
  }

	CHECK_HW_INTERFACE();
		
	yat::uint16 l_filter_nb = 0;
	attr.get_write_value(l_filter_nb);
	m_hwInterface->set_filter_nb(l_filter_nb);	
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_filterLabel
// 
// description : 	Extract real attribute values for filterLabel acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_filterLabel(Tango::Attribute &attr)
{
	// DEBUG_STREAM << "CornerStone130::read_filterLabel(Tango::WAttribute &attr) entering... "<< endl;

	static char * __filter_label_addr__;
	static std::string __filter_label__;

  CHECK_HW_INTERFACE();

  // get current grating label
  __filter_label__ = m_hwInterface->get_filter_label();
  __filter_label_addr__ = const_cast<char*>(__filter_label__.c_str());      

  attr.set_value(&__filter_label_addr__);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_wavelength
// 
// description : 	Extract real attribute values for wavelength acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_wavelength(Tango::Attribute &attr)
{
	// DEBUG_STREAM << "CornerStone130::read_wavelength(Tango::WAttribute &attr) entering... "<< endl;
	
  static Tango::DevDouble __wave_length__ = yat::IEEE_NAN;

	CHECK_HW_INTERFACE();

  // get current wavelength
	__wave_length__ = m_hwInterface->get_wavelength();
	attr.set_value(&__wave_length__);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::write_wavelength
// 
// description : 	Write wavelength attribute values to hardware.
//
//-----------------------------------------------------------------------------
void CornerStone130::write_wavelength(Tango::WAttribute &attr)
{
  DEBUG_STREAM << "CornerStone130::write_wavelength(Tango::WAttribute &attr) entering... "<< endl;

	//- Check device state
	if (this->dev_state() != Tango::STANDBY)
	{
		THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
			_CPTC("Failed to change wavelength value - Device state must be STANDBY"),
			_CPTC("CornerStone130::write_wavelength"));
  }

  double l_wlen = yat::IEEE_NAN;
	attr.get_write_value(l_wlen);

  //- Check if not null value
  if (l_wlen == 0.0)
  {
    THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
      _CPTC("Cannot write wavelength: should be a strictly positive value!"),
			_CPTC("CornerStone130::write_wavelength"));
  }

	CHECK_HW_INTERFACE();
		
  //- check if required wl in current grating range
  // get current grating number
  yat::uint16 nb = m_hwInterface->get_grating_nb();
	if (l_wlen > m_gratings[nb].maxWaveLength)
	{
		yat::OSStream oss;
    oss << "Cannot write wavelength: value is above the maximum <"
        << m_gratings[nb].maxWaveLength << "> in operational unit.";
		THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
			oss.str().c_str(),
			_CPTC("CornerStone130::write_wavelength"));	
  }

	if (l_wlen < m_gratings[nb].minWaveLength)
	{
		yat::OSStream oss;
    oss << "Cannot write wavelength: value is below the minimum <"
        << m_gratings[nb].minWaveLength << "> in operational unit.";
		THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
			oss.str().c_str(),
			_CPTC("CornerStone130::write_wavelength"));	
  }

  // set new value
	m_hwInterface->set_wavelength(l_wlen);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_shutterClosed
// 
// description : 	Extract real attribute values for shutterClosed acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_shutterClosed(Tango::Attribute &attr)
{
	// DEBUG_STREAM << "CornerStone130::read_shutterClosed(Tango::WAttribute &attr) entering... "<< endl;

  static Tango::DevBoolean __shutter_closed__ = false;

	CHECK_HW_INTERFACE();

	if (m_hwInterface->get_shutter_state() == E_CLOSED)
  {
	  __shutter_closed__ = true;
  }
  else
  {
    __shutter_closed__ = false;
  }
	attr.set_value(&__shutter_closed__);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::read_gratingNumber
// 
// description : 	Extract real attribute values for gratingNumber acquisition result.
//
//-----------------------------------------------------------------------------
void CornerStone130::read_gratingNumber(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "CornerStone130::read_gratingNumber(Tango::WAttribute &attr) entering... "<< endl;

  static Tango::DevUShort __grating_nb__ = 0;

	CHECK_HW_INTERFACE();

  // get current filter number
	__grating_nb__ = m_hwInterface->get_grating_nb();
	attr.set_value(&__grating_nb__);

  // set associated wl range
  m_hwInterface->set_grating_range(m_gratings[__grating_nb__].maxWaveLength - m_gratings[__grating_nb__].minWaveLength);
}

//+----------------------------------------------------------------------------
//
// method : 		CornerStone130::write_gratingNumber
// 
// description : 	Write gratingNumber attribute values to hardware.
//
//-----------------------------------------------------------------------------
void CornerStone130::write_gratingNumber(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "CornerStone130::write_gratingNumber(Tango::WAttribute &attr) entering... "<< endl;

	//- Check device state
	if (this->dev_state() != Tango::STANDBY)
	{
		THROW_DEVFAILED(
      _CPTC("DEVICE_ERROR"),			
			_CPTC("Failed to change grating number - Device state must be STANDBY"),
			_CPTC("CornerStone130::write_gratingNumber"));
  }

	CHECK_HW_INTERFACE();
		
	yat::uint16 l_grating_nb = 0;
	attr.get_write_value(l_grating_nb);
	m_hwInterface->set_grating_nb(l_grating_nb);

  // set associated wave length range
  m_hwInterface->set_grating_range(m_gratings[l_grating_nb].maxWaveLength - m_gratings[l_grating_nb].minWaveLength);
}

//+------------------------------------------------------------------
/**
 *	method:	CornerStone130::abort
 *
 *	description:	method to execute "Abort"
 *	Stops monochromator.
 *
 *
 */
//+------------------------------------------------------------------
void CornerStone130::abort()
{
	DEBUG_STREAM << "CornerStone130::abort(): entering... !" << endl;
	
	CHECK_HW_INTERFACE();
	m_hwInterface->abort();
}

//+------------------------------------------------------------------
/**
 *	method:	CornerStone130::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState CornerStone130::dev_state()
{
	if (m_init_device_done)
	{
		if (m_hwInterface)
    {
      std::string status = "";
			m_curr_state = m_hwInterface->get_state_and_status(status);
    }
		else
		{
			m_curr_state = Tango::FAULT;
		}
	}

	return m_curr_state;
}

//+------------------------------------------------------------------
/**
 *	method:	CornerStone130::dev_status
 *
 *	description:	method to execute "Status"
 *	This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 * @return	Status description
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString CornerStone130::dev_status()
{
	static std::string s = "";
	yat::OSStream oss;

	if (m_init_device_done)
	{
		if (m_hwInterface)
		{
      std::string status = "";
      Tango::DevState state = m_hwInterface->get_state_and_status(status);
      
			oss << status.c_str() << endl;
		}
		else
		{
			oss << "Error accessing hardware interface" << endl;
		}
	}
	else
	{
		oss << m_curr_status.c_str() << std::endl;
	}

	s = oss.str();
	return s.c_str();
}

//==========================================================================
// CornerStone130::parse_gratings_prop
//==========================================================================
void CornerStone130::parse_gratings_prop()
	throw(Tango::DevFailed)
{
	//- parse the gratings list property
	//--------------------------------------
	for (size_t idx = 0; idx < gratings.size(); idx++)
	{
		//- parse ":"
		yat::StringTokenizer tokGratingStr (gratings[idx], ":");
		
		//- check nb of tokens
		//-----------------------------------
		if (tokGratingStr.count_tokens() != 4)
		{
			yat::OSStream oss;
			oss <<  "Property Gratings <" << gratings[idx]
      <<"> , incorrect format - {id:label:min wavelength:max wavelength}";
			
			ERROR_STREAM << m_curr_status<<std::endl;
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::parse_gratings_prop"));			 
		}
		
		//- check the value of grating identifier
		//--------------------------------------- 
		yat::uint16 idValue = tokGratingStr.next_int_token();
		if ((idValue != 2) && (idValue != 1))
		{
			yat::OSStream oss;
			oss << "Property Gratings <" << gratings[idx]
			    << "> , identifier error:\n     must be 1 or 2 ";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				_CPTC("The Gratings identifier must be 1 or 2"),
				_CPTC("CornerStone130::parse_gratings_prop"));
		}
				
		//- check the label size <= 8 
		//----------------------------
		std::string labelStr = tokGratingStr.next_token();
		if (labelStr.size() > 8)
		{
			yat::OSStream oss;
			oss << "Property Gratings <"<< gratings[idx]
			    << "> , label size must be less than 8 characters";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::parse_gratings_prop"));
		}				
			
		//- check min wavelength
		//-------------------------- 
		std::string minWlStr = tokGratingStr.next_token();
    double minWlval = yat::IEEE_NAN;
		try
		{
			//- value
			minWlval = (double)yat::XString<double>::to_num(minWlStr);
			if (minWlval <= 0)
			{
				yat::OSStream oss;
				oss << "Property Gratings <" << gratings[idx]
				    <<"> , the min wavelength must be > 0 ";
	
				THROW_DEVFAILED(
          _CPTC("CONFIGURATION_ERROR"),
					oss.str().c_str(),
					_CPTC("CornerStone130::parse_gratings_prop"));					
			}
		}
		catch(...)
		{
			yat::OSStream oss;
			oss << "Property Gratings <" << gratings[idx]
			    << "> , the min wavelength is not a number.";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::parse_gratings_prop"));
		}

		//- check max wavelength
		//-------------------------- 
		std::string maxWlStr = tokGratingStr.next_token();
    double maxWlval = yat::IEEE_NAN;
		try
		{
			//- value
			maxWlval = (double)yat::XString<double>::to_num(maxWlStr);
			if (maxWlval <= 0)
			{
				yat::OSStream oss;
				oss << "Property Gratings <" << gratings[idx]
				    <<"> , the max wavelength must be > 0 ";
	
				THROW_DEVFAILED(
          _CPTC("CONFIGURATION_ERROR"),
					oss.str().c_str(),
					_CPTC("CornerStone130::parse_gratings_prop"));					
			}
		}
		catch(...)
		{
			yat::OSStream oss;
			oss << "Property Gratings <" << gratings[idx]
			    << "> , the max wavelength is not a number.";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::parse_gratings_prop"));
		}

    //- add grating to map {idValue, gratingDef}
    GratingDef def;
    def.label = labelStr;
    def.minWaveLength = minWlval;
    def.maxWaveLength = maxWlval;
    m_gratings.insert(Gratings_pair_t(idValue, def));
	}
}

//==========================================================================
// CornerStone130::parse_filters_prop
//==========================================================================
void CornerStone130::parse_filters_prop()
	throw(Tango::DevFailed)
{
	//- parse the filters list property and fill associated map
	//---------------------------------------------------------
	for (size_t idx = 0; idx < filters.size(); idx++)
	{
		//- parse ":"
		yat::StringTokenizer tokFilterStr (filters[idx], ":");

		//- check nb of tokens
		//-----------------------------------
		if (tokFilterStr.count_tokens () != 2)
		{
			yat::OSStream oss;
			oss << "Property Filters <" << filters[idx]
			    << "> , incorrect format - {id:label}";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::get_device_property"));			 
		}
		
		//- check the value of filter identifier
		//-------------------------------------- 
		yat::uint16 idValue = tokFilterStr.next_int_token();
		if ((idValue < 1) || (idValue > 6))
		{
			yat::OSStream oss;
			oss << "Property Filters <" << filters[idx]
			    << "> , identifier error:\n     must be in [1 .. 6]";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::get_device_property"));
		}
				
		//- check the label size <= 8
		//---------------------------
		std::string labelStr = tokFilterStr.next_token();
		if (labelStr.size() > 8)
		{
			yat::OSStream oss;
			oss << "Property Gratings <"
			    << filters[idx]
				<< "> , label size must be less than 8 characters";
			
			THROW_DEVFAILED(
        _CPTC("CONFIGURATION_ERROR"),
				oss.str().c_str(),
				_CPTC("CornerStone130::parse_filters_prop"));
		}	

    // add filter to map {idValue, labelStr}
    m_filters.insert(Filters_pair_t(idValue, labelStr));
	}	
}

}	//	namespace
